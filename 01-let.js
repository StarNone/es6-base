// let 所声明的变量只在let命令所在的代码块内有效

// for 循环中函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域

// let 所声明的变量一定要在声明后使用，否则报错

// 在一个块级作用域中，在let命令声明的变量之前，都属于这个变量的“死区”，只要使用该变量
// 就会报错，这段区域在语法上称为“暂时性死区”（tempporal dead zone，简称TDZ）

// let x = x 报错 在变量x的声明语句还没有执行完成前取用x的值，导致报错“x 未定义”

// 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，
// 只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

// let 不允许在相同作用域内，重复声明同一个变量。

// 为什么需要块级作用域？
// es5 只有全局作用域和函数作用域，没有块级作用域，就造成了以下一些问题：
// 1.内层变量可能会覆盖外层变量
//   {
//       var tmp = new Date();
//       function f() {
//           console.log(tmp);
//           if(false){
//               var tmp = 'hello world';
//           }
//       }
//       f();//undefined
//   }
// //   if 代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果
// //   为undefi，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
// // 2.用来计数的循环变量泄露为全局变量
//   {
//       var s = "hello";
//       for(var i = 0; i < s.length; i++){
//           console.log(s[i]);
//       }
//       console.log(i);//5
//   }
